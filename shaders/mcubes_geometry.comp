// Copyright 2021 NVIDIA CORPORATION
// SPDX-License-Identifier: Apache-2.0
//
// Compute shader for performing marching cubes on a section of the input 3D image and
// generating a McubesGeometry data structure holding the iso-triangles found.
// Dispatch with x = MCUBES_GEOMETRIES_PER_CHUNK, y,z = 1.
// Each workgroup fills one element of the bound McubesGeometry array.
#version 460
#include "mcubes_geometry.h"
#include "mcubes_params.h"

#define THREADS 128
layout(local_size_x = THREADS) in;

shared uint validCellCount;

layout(push_constant) uniform PushConstantBlock
{
  McubesParams pushConstant;
};

layout(set = 0, binding = MCUBES_IMAGE_BINDING, r32f) uniform readonly image3D inputImage;
layout(set = 0, binding = MCUBES_GEOMETRY_BINDING) buffer GeometryBuffer
{
  McubesGeometry geometryArray[];
};

#include "autogenerated_mcubes.glsl"

// Analyze the 8 samples in the grid from texelCoord to texelCoord + (1,1,1).
// If any triangles are found, append to McubesGeometry::cells, incrementing validCellCount.
void analyzeCell(uvec3 texelCoord)
{
  float sample000 = imageLoad(inputImage, ivec3(texelCoord + uvec3(0, 0, 0))).x;
  float sample001 = imageLoad(inputImage, ivec3(texelCoord + uvec3(0, 0, 1))).x;
  float sample010 = imageLoad(inputImage, ivec3(texelCoord + uvec3(0, 1, 0))).x;
  float sample011 = imageLoad(inputImage, ivec3(texelCoord + uvec3(0, 1, 1))).x;
  float sample100 = imageLoad(inputImage, ivec3(texelCoord + uvec3(1, 0, 0))).x;
  float sample101 = imageLoad(inputImage, ivec3(texelCoord + uvec3(1, 0, 1))).x;
  float sample110 = imageLoad(inputImage, ivec3(texelCoord + uvec3(1, 1, 0))).x;
  float sample111 = imageLoad(inputImage, ivec3(texelCoord + uvec3(1, 1, 1))).x;

  uint caseNumber = autogeneratedGetCaseNumber(sample000, sample001, sample010, sample011,  //
                                               sample100, sample101, sample110, sample111);
  if(caseNumber != 0 && caseNumber != 255u)
  {
    uint cellIndex = atomicAdd(validCellCount, 1u);
    if(cellIndex < MCUBES_CELLS_PER_GEOMETRY)
    {
      geometryArray[gl_WorkGroupID.x].cells[cellIndex].offset =
          pushConstant.offset + pushConstant.size * (vec3(texelCoord) / MCUBES_CHUNK_EDGE_LENGTH_CELLS);
      autogeneratedGetCellTriangles(geometryArray[gl_WorkGroupID.x].cells[cellIndex], caseNumber, 512u,  //
                                    sample000, sample001, sample010, sample011,                          //
                                    sample100, sample101, sample110, sample111);
    }
  }
}

void main()
{
  // Initialize atomic counter of number of non-empty cells found.
  if(gl_LocalInvocationIndex == 0)
  {
    validCellCount = 0;
  }
  barrier();

  const uint edgeLength = MCUBES_GEOMETRY_EDGE_LENGTH;
  const uint xStep      = 256u % edgeLength;
  const uint yStep      = 256u / edgeLength;

  // Deduce which subsection of the input image that this work group will analyze.
  const uint gridLength = uint(MCUBES_CHUNK_EDGE_LENGTH_TEXELS) / edgeLength;
  uint       xGrid      = gl_WorkGroupID.x % gridLength;
  uint       yGrid      = (gl_WorkGroupID.x / gridLength) % gridLength;
  uint       zGrid      = gl_WorkGroupID.x / (gridLength * gridLength);
  uvec3      baseOffset = uvec3(xGrid, yGrid, zGrid) * MCUBES_GEOMETRY_EDGE_LENGTH;  // Lower-left of subsection.

  // Iterate over all cells -- take care that upper boundary subsections are 1 texel smaller, because
  // cells exist strictly between sample locations.
  for(uint cellIndex = gl_LocalInvocationIndex; cellIndex < MCUBES_CELLS_PER_GEOMETRY; cellIndex += THREADS)
  {
    uvec3 cellOffset;
    cellOffset.x     = cellIndex % uint(MCUBES_GEOMETRY_EDGE_LENGTH);
    cellOffset.y     = (cellIndex / uint(MCUBES_GEOMETRY_EDGE_LENGTH)) % uint(MCUBES_GEOMETRY_EDGE_LENGTH);
    cellOffset.z     = cellIndex / uint(MCUBES_GEOMETRY_EDGE_LENGTH * MCUBES_GEOMETRY_EDGE_LENGTH);
    uvec3 texelCoord = baseOffset + cellOffset;
    // Bounds check: again, note -2u.
    if(clamp(texelCoord, uvec3(0), uvec3(MCUBES_CHUNK_EDGE_LENGTH_TEXELS - 2u)) == texelCoord)
    {
      analyzeCell(texelCoord);
    }
  }

  barrier();

  if(gl_LocalInvocationIndex == 0)
  {
    // Record number of cells found, convert to VkDrawIndirectCommand.
    geometryArray[gl_WorkGroupID.x].vertexCount   = 12 * min(validCellCount, uint(MCUBES_CELLS_PER_GEOMETRY));
    geometryArray[gl_WorkGroupID.x].instanceCount = 1;
    geometryArray[gl_WorkGroupID.x].firstVertex   = 0;
    geometryArray[gl_WorkGroupID.x].firstInstance = 0;

    // Record the scale used for packed vertices (0 = 0.0, 512 = 1 texel distance)
    geometryArray[gl_WorkGroupID.x].packedVertScale =
        pushConstant.size / MCUBES_CHUNK_EDGE_LENGTH_CELLS * (1.0 / 512.0);
  }
}
